### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from .protocol_pb2_grpc import *
import protocol_pb2
from .protocol_pb2 import *
from ._support import MessageWrapper, ArgumentError

__all__ = [
    "ProtocolService",
    "ProtocolRunUserInfo",
    "StartProtocolRequest",
    "StartProtocolResponse",
    "StopProtocolRequest",
    "StopProtocolResponse",
    "ListProtocolsRequest",
    "ProtocolInfo",
    "ListProtocolsResponse",
    "WaitForFinishedRequest",
    "GetRunInfoRequest",
    "ProtocolRunInfo",
    "ListProtocolRunsRequest",
    "ListProtocolRunsResponse",
    "GetCurrentProtocolRunRequest",
    "GetCurrentProtocolRunResponse",
    "WatchCurrentProtocolRunRequest",
    "GetContextInfoRequest",
    "GetContextInfoResponse",
    "SetContextInfoRequest",
    "SetContextInfoResponse",
    "GetSampleIdRequest",
    "GetSampleIdResponse",
    "SetSampleIdRequest",
    "SetSampleIdResponse",
    "GetProtocolPurposeRequest",
    "GetProtocolPurposeResponse",
    "SetProtocolPurposeRequest",
    "SetProtocolPurposeResponse",
    "ProtocolState",
    "PROTOCOL_RUNNING",
    "PROTOCOL_COMPLETED",
    "PROTOCOL_STOPPED_BY_USER",
    "PROTOCOL_FINISHED_WITH_ERROR",
]

class ProtocolService(object):
    def __init__(self, channel):
        self._stub = ProtocolServiceStub(channel)
        self._pb = protocol_pb2

    def start_protocol(self, _message=None, _timeout=None, **kwargs):
        """
        Initiates a python instance that runs the script specified by the `path` argument.
        `list_protocols` will give back a list of protocol scripts that can be started by this call

        :param identifier: (required)
            The identifier of the protocol, as provided by list_protocols().
        :param args:
            The arguments to pass to the protocol.
        :param user_info:
            User input describing the protocol.
        :rtype: StartProtocolResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.start_protocol(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = StartProtocolRequest()

        if 'identifier' in kwargs:
            unused_args.remove('identifier')
            _message.identifier = kwargs['identifier']
        else:
            raise ArgumentError("start_protocol requires a 'identifier' argument")

        if 'args' in kwargs:
            unused_args.remove('args')
            _message.args.extend(kwargs['args'])

        if 'user_info' in kwargs:
            unused_args.remove('user_info')
            _message.user_info.CopyFrom(kwargs['user_info'])

        if len(unused_args) > 0:
            raise ArgumentError("start_protocol got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.start_protocol(_message, timeout=_timeout), unwraps=[])

    def stop_protocol(self, _message=None, _timeout=None, **kwargs):
        """
        Stops the currently running protocol script instance

        :rtype: StopProtocolResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.stop_protocol(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = StopProtocolRequest()

        if len(unused_args) > 0:
            raise ArgumentError("stop_protocol got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.stop_protocol(_message, timeout=_timeout), unwraps=[])

    def wait_for_finished(self, _message=None, _timeout=None, **kwargs):
        """
        Wait for a protocol run to finish.

        The call blocks until the run with the given run ID has finished (or returns immediately if
        it had already finished) and returns information about the protocol run.

        If no run has been started with the provided run ID (or no run ID is given), an error is
        returned.

        If NOTIFY_BEFORE_TERMINATION is specified for state, the protocol end time is an estimate, including
        the allowed timeout.

        Since 1.10

        :param run_id: (required)
            Only consider a specific protocol run.
        :param state:
            Control what to wait for.

            Specifying NOTIFY_BEFORE_TERMINATION allows a caller to be notified the script will be ended _soon_,
            and do final work to end cleanly.

            Since 1.11
        :rtype: ProtocolRunInfo
        """
        if _message is not None:
            return MessageWrapper(self._stub.wait_for_finished(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = WaitForFinishedRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            _message.run_id = kwargs['run_id']
        else:
            raise ArgumentError("wait_for_finished requires a 'run_id' argument")

        if 'state' in kwargs:
            unused_args.remove('state')
            _message.state = kwargs['state']

        if len(unused_args) > 0:
            raise ArgumentError("wait_for_finished got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.wait_for_finished(_message, timeout=_timeout), unwraps=[])

    def get_run_info(self, _message=None, _timeout=None, **kwargs):
        """
        Gets information about a protocol run.

        If no run ID is provided, information about the most recently started protocol run is
        provided.

        Since 1.10

        :param run_id:
            The protocol run to get information about.
        :rtype: ProtocolRunInfo
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_run_info(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetRunInfoRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            _message.run_id = kwargs['run_id']

        if len(unused_args) > 0:
            raise ArgumentError("get_run_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_run_info(_message, timeout=_timeout), unwraps=[])

    def list_protocol_runs(self, _message=None, _timeout=None, **kwargs):
        """
        List previously started protocol run ids (including any current protocol), in order of starting.

        The returned object can be used to find protocol information with get_run_info.

        Since 1.11

        :rtype: ListProtocolRunsResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.list_protocol_runs(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = ListProtocolRunsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("list_protocol_runs got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.list_protocol_runs(_message, timeout=_timeout), unwraps=[])

    def get_current_protocol_run(self, _message=None, _timeout=None, **kwargs):
        """
        Returns the name and run id of the currently running protocol.

        Will fail with FAILED_PRECONDITION if there is no protocol running

        Since 1.11

        :rtype: ProtocolRunInfo
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_current_protocol_run(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetCurrentProtocolRunRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_current_protocol_run got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_current_protocol_run(_message, timeout=_timeout), unwraps=[])

    def watch_current_protocol_run(self, _message=None, _timeout=None, **kwargs):
        """
        Returns current protocol run info and streams any changes to the current protocol

        This call can be made even if there is no current protocol running. In this case, the next streamed
        response will be the start of a new protocol instance and you will receive updates for that protocol
        until it finishes

        If a protocol finishes this stream will still continue to run and you will be notified when a new protocol starts

        Since 1.12

        :rtype: ProtocolRunInfo
        """
        if _message is not None:
            return MessageWrapper(self._stub.watch_current_protocol_run(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = WatchCurrentProtocolRunRequest()

        if len(unused_args) > 0:
            raise ArgumentError("watch_current_protocol_run got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.watch_current_protocol_run(_message, timeout=_timeout), unwraps=[])

    def list_protocols(self, _message=None, _timeout=None, **kwargs):
        """
        Gives back a list that contains info about each possible protocol script minknow is aware of.
        This will most likely be used to retrieve a suitable protocol script that can be passed on to `start_protocol`

        Since 1.10

        :rtype: ListProtocolsResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.list_protocols(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = ListProtocolsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("list_protocols got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.list_protocols(_message, timeout=_timeout), unwraps=[])

    def get_context_info(self, _message=None, _timeout=None, **kwargs):
        """
        Returns string-to-string map of the context tags

        Since 1.11

        :rtype: GetContextInfoResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_context_info(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetContextInfoRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_context_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_context_info(_message, timeout=_timeout), unwraps=[])

    def set_context_info(self, _message=None, _timeout=None, **kwargs):
        """
        Store context tags as arbitary string-to-string map

        Since 1.11

        :param context_info:
        :rtype: SetContextInfoResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.set_context_info(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = SetContextInfoRequest()

        if 'context_info' in kwargs:
            unused_args.remove('context_info')
            _message.context_info.update(kwargs['context_info'])

        if len(unused_args) > 0:
            raise ArgumentError("set_context_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_context_info(_message, timeout=_timeout), unwraps=[])

    def get_sample_id(self, _message=None, _timeout=None, **kwargs):
        """
        Sample id is a value set from the GUI that is defined by the user to identify an experiment.
        This call gets this value

        Since 1.11

        :rtype: GetSampleIdResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_sample_id(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetSampleIdRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_sample_id got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_sample_id(_message, timeout=_timeout), unwraps=[])

    def set_sample_id(self, _message=None, _timeout=None, **kwargs):
        """
        Sets the sample id. Refer to get_sample_id for what sample id is used for

        Since 1.11

        :param sample_id:
        :rtype: SetSampleIdResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.set_sample_id(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = SetSampleIdRequest()

        if 'sample_id' in kwargs:
            unused_args.remove('sample_id')
            _message.sample_id = kwargs['sample_id']

        if len(unused_args) > 0:
            raise ArgumentError("set_sample_id got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_sample_id(_message, timeout=_timeout), unwraps=[])

    def get_protocol_purpose(self, _message=None, _timeout=None, **kwargs):
        """
        Value set by protocol scripts to define the purpose of the script. Gets this value

        Since 1.11

        :rtype: GetProtocolPurposeResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_protocol_purpose(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetProtocolPurposeRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_protocol_purpose got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_protocol_purpose(_message, timeout=_timeout), unwraps=[])

    def set_protocol_purpose(self, _message=None, _timeout=None, **kwargs):
        """
        Sets the protocol purpose. See also get_protocol_purpose

        Since 1.11

        :param purpose:
        :rtype: SetProtocolPurposeResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.set_protocol_purpose(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = SetProtocolPurposeRequest()

        if 'purpose' in kwargs:
            unused_args.remove('purpose')
            _message.purpose = kwargs['purpose']

        if len(unused_args) > 0:
            raise ArgumentError("set_protocol_purpose got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_protocol_purpose(_message, timeout=_timeout), unwraps=[])


